{"ast":null,"code":"function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React, { Component } from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport PropTypes from 'prop-types';\nimport debounce from 'lodash/debounce';\nimport Preview from 'rsg-components/Preview';\nimport Para from 'rsg-components/Para';\nimport Slot from 'rsg-components/Slot';\nimport PlaygroundRenderer from 'rsg-components/Playground/PlaygroundRenderer';\nimport { EXAMPLE_TAB_CODE_EDITOR } from '../slots';\nimport { DisplayModes, ExampleModes } from '../../consts';\n\nvar Playground =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Playground, _Component);\n\n  function Playground(props, context) {\n    var _this;\n\n    _this = _Component.call(this, props, context) || this;\n    var code = props.code,\n        settings = props.settings,\n        exampleMode = props.exampleMode;\n    var config = context.config;\n    var expandCode = exampleMode === ExampleModes.expand;\n    var activeTab = settings.showcode !== undefined ? settings.showcode : expandCode;\n    _this.state = {\n      code: code,\n      prevCode: code,\n      activeTab: activeTab ? EXAMPLE_TAB_CODE_EDITOR : undefined\n    };\n    _this.handleTabChange = _this.handleTabChange.bind(_assertThisInitialized(_this));\n    _this.handleChange = debounce(_this.handleChange.bind(_assertThisInitialized(_this)), config.previewDelay);\n    return _this;\n  }\n\n  Playground.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    var code = nextProps.code;\n\n    if (prevState.prevCode !== code) {\n      return {\n        prevCode: code,\n        code: code\n      };\n    }\n\n    return null;\n  };\n\n  var _proto = Playground.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    // Clear pending changes\n    this.handleChange.cancel();\n  };\n\n  _proto.handleChange = function handleChange(code) {\n    this.setState({\n      code: code\n    });\n  };\n\n  _proto.handleTabChange = function handleTabChange(name) {\n    this.setState(function (state) {\n      return {\n        activeTab: state.activeTab !== name ? name : undefined\n      };\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$state = this.state,\n        code = _this$state.code,\n        activeTab = _this$state.activeTab;\n    var _this$props = this.props,\n        evalInContext = _this$props.evalInContext,\n        index = _this$props.index,\n        name = _this$props.name,\n        settings = _this$props.settings,\n        exampleMode = _this$props.exampleMode;\n    var displayMode = this.context.displayMode;\n    var isExampleHidden = exampleMode === ExampleModes.hide;\n    var isEditorHidden = settings.noeditor || isExampleHidden;\n    var preview = React.createElement(Preview, {\n      code: code,\n      evalInContext: evalInContext\n    });\n    return isEditorHidden ? React.createElement(Para, null, preview) : React.createElement(PlaygroundRenderer, {\n      name: name,\n      exampleIndex: index,\n      preview: preview,\n      previewProps: settings.props || {},\n      tabButtons: React.createElement(Slot, {\n        name: \"exampleTabButtons\",\n        active: activeTab,\n        props: {\n          onClick: this.handleTabChange\n        }\n      }),\n      tabBody: React.createElement(Slot, {\n        name: \"exampleTabs\",\n        active: activeTab,\n        onlyActive: true // evalInContext passed through to support custom slots that eval code\n        ,\n        props: {\n          code: code,\n          onChange: this.handleChange,\n          evalInContext: evalInContext\n        }\n      }),\n      toolbar: React.createElement(Slot, {\n        name: \"exampleToolbar\",\n        props: {\n          name: name,\n          isolated: displayMode === DisplayModes.example,\n          example: index\n        }\n      })\n    });\n  };\n\n  return Playground;\n}(Component);\n\n_defineProperty(Playground, \"propTypes\", {\n  code: PropTypes.string.isRequired,\n  evalInContext: PropTypes.func.isRequired,\n  index: PropTypes.number.isRequired,\n  name: PropTypes.string.isRequired,\n  exampleMode: PropTypes.string.isRequired,\n  settings: PropTypes.object\n});\n\n_defineProperty(Playground, \"contextTypes\", {\n  config: PropTypes.object.isRequired,\n  displayMode: PropTypes.string\n});\n\nexport default polyfill(Playground);","map":null,"metadata":{},"sourceType":"module"}